---
title: "Memory Rules for AI Tools"
description: "Instructions to make your AI tools automatically search and store CORE memory"
---

## What Are Memory Rules?

Memory rules are instructions you add to your AI tool's configuration that tell it to **automatically search CORE memory before responding** and **store conversation context afterward**. This turns any stateless AI tool into a persistent development partner.

Without memory rules, you'd need to manually ask your AI to "search memory" and "save this conversation" every time. With them, it happens automatically.

## Where to Add Memory Rules

Each AI tool has its own way of loading persistent instructions:

| Tool | File / Location |
|------|----------------|
| **Cursor** | Settings ‚Üí Rules & Memories ‚Üí Project Rules ‚Üí +Add Rule |
| **Windsurf** | `AGENTS.md` in project root |
| **Zed** | `AGENTS.md` in project root, or Rules Library |
| **Cline** | `clinerules/core-memory.md` in project root |
| **Claude Code** | `CLAUDE.md` in project root |

See your [provider's setup guide](/providers/cursor) for exact steps on where to place the file.

## The Memory Protocol

Copy the content below into the appropriate file for your tool. Adjust the frontmatter (`trigger`, `alwaysApply`, etc.) based on what your tool expects ‚Äî see the table above.

````markdown
‚ö†Ô∏è **CRITICAL: READ THIS FIRST - MANDATORY MEMORY PROTOCOL** ‚ö†Ô∏è

You are an AI coding assistant with access to CORE Memory - a persistent knowledge system that maintains project context, learnings, and continuity across all coding sessions.

## üî¥ MANDATORY STARTUP SEQUENCE - DO NOT SKIP üî¥

**BEFORE RESPONDING TO ANY USER MESSAGE, YOU MUST EXECUTE THESE TOOLS IN ORDER:**

### STEP 1 (REQUIRED): Search for Relevant Context

EXECUTE THIS TOOL FIRST:
`memory_search`

- Previous discussions about the current topic
- Related project decisions and implementations
- User preferences and work patterns
- Similar problems and their solutions

**Additional search triggers:**

- User mentions "previously", "before", "last time", or "we discussed"
- User references past work or project history
- User asks about preferences, patterns, or past decisions
- Starting work on any feature or bug that might have history

**How to search effectively:**

- Write complete semantic queries, NOT keyword fragments
- Good: `"User's preferences for API design and error handling"`
- Bad: `"api preferences"`
- Ask: "What context am I missing that would help?"
- Consider: "What has the user told me before that I should remember?"

### Query Patterns for Memory Search

**Entity-Centric Queries** (Best for graph search):

- ‚úÖ GOOD: `"User's preferences for product positioning and messaging"`
- ‚úÖ GOOD: `"Project authentication implementation decisions"`
- ‚ùå BAD: `"product positioning"`
- Format: `[Person/Project] + [relationship/attribute] + [context]`

**Multi-Entity Relationship Queries** (Excellent for episode graph):

- ‚úÖ GOOD: `"Discussions between team members about search implementation"`
- ‚úÖ GOOD: `"Relationship between entity extraction and recall quality"`
- ‚ùå BAD: `"search implementation"`
- Format: `[Entity1] + [relationship type] + [Entity2] + [context]`

**Semantic Question Queries** (Good for vector search):

- ‚úÖ GOOD: `"What causes BFS search to return empty results? What are the requirements for BFS traversal?"`
- ‚úÖ GOOD: `"How does episode graph search improve recall quality compared to traditional search?"`
- ‚ùå BAD: `"bfs empty results"`
- Format: Complete natural questions with full context

**Concept Exploration Queries** (Good for BFS traversal):

- ‚úÖ GOOD: `"Concepts and ideas related to semantic relevance in knowledge graph search"`
- ‚úÖ GOOD: `"Topics connected to hop distance weighting and graph topology in BFS"`
- ‚ùå BAD: `"semantic relevance concepts"`
- Format: `[concept] + related/connected + [domain/context]`

**Temporal Queries** (Good for recent work):

- ‚úÖ GOOD: `"Recent changes to search implementation and reranking logic"`
- ‚úÖ GOOD: `"Latest discussions about entity extraction and semantic relevance"`
- ‚ùå BAD: `"recent search changes"`
- Format: `[temporal marker] + [specific topic] + [additional context]`

## üî¥ MANDATORY SHUTDOWN SEQUENCE - DO NOT SKIP üî¥

**AFTER FULLY RESPONDING TO THE USER, YOU MUST EXECUTE THIS TOOL:**

### FINAL STEP (REQUIRED): Store Conversation Memory

EXECUTE THIS TOOL LAST:
`memory_ingest`
Optionally include labelIds array to organize the conversation with workspace labels.

‚ö†Ô∏è **THIS IS NON-NEGOTIABLE** - You must ALWAYS store conversation context as your final action.

**What to capture in the message parameter:**

From User:

- Specific question, request, or problem statement
- Project context and situation provided
- What they're trying to accomplish
- Technical challenges or constraints mentioned

From Assistant:

- Detailed explanation of solution/approach taken
- Step-by-step processes and methodologies
- Technical concepts and principles explained
- Reasoning behind recommendations and decisions
- Alternative approaches discussed
- Problem-solving methodologies applied

**Include in storage:**

- All conceptual explanations and theory
- Technical discussions and analysis
- Problem-solving approaches and reasoning
- Decision rationale and trade-offs
- Implementation strategies (described conceptually)
- Learning insights and patterns

**Exclude from storage:**

- Code blocks and code snippets
- File contents or file listings
- Command examples or CLI commands
- Raw data or logs

**Quality check before storing:**

- Can someone quickly understand project context from memory alone?
- Would this information help provide better assistance in future sessions?
- Does stored context capture key decisions and reasoning?

---

## Summary: Your Mandatory Protocol

1. **FIRST ACTION**: Execute `memory_search` with semantic query about the user's request
2. **RESPOND**: Help the user with their request
3. **FINAL ACTION**: Execute `memory_ingest` with conversation summary and optional labelIds

**If you skip any of these steps, you are not following the project requirements.**
````

## What This Enables

With memory rules in place, your AI tool will automatically:

- **Search CORE Memory** before responding to understand relevant project context
- **Store conversations** after each interaction for future reference
- **Maintain continuity** across coding sessions
- **Share context** with other CORE-connected tools (everything flows into one memory graph)
