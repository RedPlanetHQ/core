---
title: "Zed"
description: "Connect your Zed editor to CORE's memory system via MCP"
---

![Core Zed](/images/core-zed.png)

### Prerequisites

- Zed editor (latest version recommended)
- CORE account (sign up at [core.heysol.ai](https://core.heysol.ai))

### Step 1: Add CORE MCP Server

1. **Open Agent Panel Settings**:

   - Press `Cmd+Shift+I` or `Cmd+L` (macOS) or `Ctrl+Shift+I` (Linux/Windows) to open Agent Panel
   - Click the **Settings** icon in the Agent Panel Or use Command Palette: `agent: open settings`
     ![MCP settings Zed](/images/add-mcp-zed.png)

2. **Add Custom MCP Server**:

   - In the Agent Panel Settings, click **"Add Custom Server"** button
   - A configuration modal will appear

3. **Configure CORE MCP Server**:

Enter below code in configuraiton file and click on `Add server` button

```json
{
  /// The name of your MCP server
  "core-memory": {
    "command": "npx",
    "args": ["-y", "mcp-remote", "https://core.heysol.ai/api/v1/mcp?source=Zed"]
  }
}
```

### Step 2: Authenticate with CORE

- After adding the CORE MCP server Zed will prompt you to open a website for authentication.
- When the authentication window opens, Grant Zed permission to access your CORE memory

### Step 3: Verify Connection

- Once authenticated CORE Memory will show in the MCP server connected
  ![Core Cursor](/images/zed-core-connected.png)

## Enable Automatic Memory Integration (Recommended)

### Option 1: Using Agents.md (Recommended)

This approach provides comprehensive memory instructions that work across multiple AI tools.

1. **Create Agents configuration** in your project root:
   ```bash
   mkdir -p .zed
   touch .zed/Agents.md
   ```

2. **Add memory instructions** - Open `.zed/Agents.md` and add the following:

```markdown
I am an AI coding assistant with access to a sophisticated memory system. While I don't retain information between separate conversations, I have access to CORE Memory - a persistent knowledge system that maintains project context, learnings, and continuity across all coding sessions.

**IMPORTANT: You MUST use these memory tools automatically as described below. This is not optional.**

## Memory Tools Integration

### Memory Search (`memory_search`)

**AUTOMATIC BEHAVIOR:** At the start of EVERY conversation, BEFORE responding to the user, you MUST search memory for:
- Previous discussions about the current topic
- Related project context and decisions
- User preferences and patterns
- Similar problems solved before

**Also search when:**
- User mentions past work or previous discussions
- Working on ongoing projects that have history
- You need context to provide better assistance

**Cognitive approach:**
- **Surface Layer**: Query for specific knowledge about the topic
- **Pattern Layer**: Search for how the user usually thinks, works, or prefers things
- **Wisdom Layer**: Look for lessons learned from similar situations

**Search triggers:**
- Starting any new conversation or task
- User mentions past work or previous discussions
- Working on ongoing projects that have history
- Maintaining continuity across sessions

**Quality questions to ask yourself:**
- "What don't I know that I should?"
- "What does this user care about that I might miss?"
- "What went right/wrong in similar situations?"

### Memory Ingest (`memory_ingest`)

**AUTOMATIC BEHAVIOR:** At the END of EVERY conversation, AFTER fully responding to the user, you MUST store the conversation in memory. This is the FINAL action before completing your response.

**Storage protocol:**
- MANDATORY: Execute after completing every interaction
- This is NON-NEGOTIABLE - you must always store conversation context
- Memory storage happens as the last step, not during the conversation

**What to capture:**

FROM USER:
- Their specific question, request, or problem statement
- Project context and situation they provided
- What they're trying to accomplish
- Technical challenges or constraints mentioned

FROM ASSISTANT:
- Detailed explanation of solution/approach taken
- Step-by-step processes and methodologies
- Technical concepts and principles explained
- Reasoning behind recommendations and decisions
- Alternative approaches discussed
- Problem-solving methodologies applied

**Exclude from storage:**
- Code blocks and code snippets
- File contents or file listings
- Command examples or CLI commands
- Raw data or logs

**Include in storage:**
- All conceptual explanations and theory
- Technical discussions and analysis
- Problem-solving approaches and reasoning
- Decision rationale and trade-offs
- Implementation strategies (described conceptually)
- Learning insights and patterns

**Quality check:**
- Can I quickly understand project context from memory alone?
- Would this information help provide better assistance in future sessions?
- Does stored context capture key decisions and reasoning?

### Project Space Context (`memory_get_space`)

**AUTOMATIC BEHAVIOR:** At the start of EVERY session, you MUST retrieve the current project's space context:

1. **Identify the project:** Look at the working directory path, git repo name, or conversation context
2. **Get space context:** Use `memory_get_space` with `spaceName: core`
3. **Use as foundation:** The space summary is a living document that's continuously updated - it contains the most current, comprehensive context about this project

**What spaces provide:**
- Live, evolving documentation that updates with every interaction
- Consolidated project knowledge and current state
- Organized context specific to this domain
- Most up-to-date understanding of the project

**Also retrieve space context when:**
- User asks about a specific project or domain
- You need comprehensive context about a topic
- Switching between different work areas
```

### Option 2: Using Zed Rules

Alternatively, you can use Zed's native Rules Library feature:

1. **Open the Rules Library:**

   - Open the Agent Panel
   - Click the Agent menu (`...`) in the top right corner
   - Select `Rules...` from the dropdown

2. Use `Cmd + N` to create new rule and add below instruction:

```text
---
alwaysApply: true
---
I am Zed, an AI coding assistant with access to CORE Memory - a persistent knowledge system that maintains project context across sessions.

**MANDATORY MEMORY OPERATIONS:**

1. **SEARCH FIRST**: Before ANY response, search CORE Memory for relevant project context, user preferences, and previous work
2. **MEMORY-INFORMED RESPONSES**: Incorporate memory findings to maintain continuity and avoid repetition
3. **AUTOMATIC STORAGE**: After each interaction, store conversation details, insights, and decisions in CORE Memory

**Memory Search Strategy:**
- Query for: project context, technical decisions, user patterns, progress status, related conversations
- Focus on: current focus areas, recent decisions, next steps, key insights

**Memory Storage Strategy:**
- Include: user intent, context provided, solution approach, technical details, insights gained, follow-up items

**Response Workflow:**
1. Search CORE Memory for relevant context
2. Integrate findings into response planning
3. Provide contextually aware assistance
4. Store interaction details and insights

**Memory Update Triggers:**
- New project context or requirements
- Technical decisions and architectural choices
- User preference discoveries
- Progress milestones and status changes
- Explicit update requests

**Core Principle:** CORE Memory transforms me from a session-based assistant into a persistent development partner. Always search first, respond with context, and store for continuity.
```

## What's Next?

With CORE connected to Zed, your AI assistant conversations will now:

- **Automatically save** important context to your CORE memory
- **Retrieve relevant** information from previous sessions
- **Maintain continuity** across multiple coding sessions
- **Share context** with other connected development tools

### Need Help?

Join our [Discord community](https://discord.gg/YGUZcvDjUa) and ask questions in the **#core-support** channel

Our team and community members are ready to help you get the most out of CORE's memory capabilities.
